# Management Wire Serialization

Status: Developed

## Objectives

- Define the hand-rolled wire format used by management socket and WebSocket connectors.
- Keep domain/action IDs and payload shapes unchanged while replacing bincode payload encoding.
- Require `workflow_id` for request/response correlation.
- Define a deterministic optional-field bitset shared by Rust and TypeScript.
- Keep Rust and TypeScript encoders/decoders aligned with shared fixtures and tests.
- Require per-action fixtures and cross-language vector tests for every management domain.

## Technical Details

### Fixture Registry and Cross-Language Vectors

- A single shared fixture registry covers every request/response action across management domains.
- Both Rust and TypeScript tests must:
  - Decode fixture hex into payloads and compare to the JSON payload.
  - Encode payloads to hex and compare to the fixture hex.
- The fixture registry is the authoritative source for protocol conformance across languages.

#### Fixture Registry Spec

Location: `nop/tests/fixtures/management-wire-vectors.json`

Schema:

```json
{
  "version": 1,
  "entries": [
    {
      "name": "content.list.request",
      "direction": "request",
      "domain_id": 12,
      "action_id": 1,
      "payload": { "...": "..." },
      "hex": "..."
    }
  ]
}
```

Rules:

- `direction` is `request` or `response` and selects the codec registry for the test runner.
- `hex` is the payload bytes only (no envelope), encoded in lowercase hex.
- Payload field names follow Rust struct JSON names (`snake_case`).
- `Vec<u8>` values are represented as JSON arrays of byte integers (0-255).
- Optional fields use JSON `null` when omitted.
- `u64` values must fit within JS safe integer range or be expressed as decimal strings; tests
  must support both representations.
- The registry is generated by `nop/src/bin/management_wire_vectors.rs`; update payload samples
  there and regenerate the JSON whenever protocol payload shapes change.

#### Fixture Coverage Matrix

#### System (domain 0)

- Requests: `Ping` (1), `LoggingGet` (4), `LoggingSet` (7), `LoggingClear` (10)
- Responses: `Pong` (2), `PongError` (3), `LoggingGetOk` (5), `LoggingGetErr` (6),
  `LoggingSetOk` (8), `LoggingSetErr` (9), `LoggingClearOk` (11), `LoggingClearErr` (12)

#### Users (domain 1)

- Requests: `Add` (1), `Change` (2), `Delete` (3), `PasswordSet` (4), `List` (5), `Show` (6),
  `RoleAdd` (7), `RoleRemove` (8), `RolesList` (9), `PasswordSalt` (10), `PasswordValidate` (11),
  `PasswordUpdate` (12)
- Responses: `AddOk` (101), `AddErr` (102), `ChangeOk` (201), `ChangeErr` (202), `DeleteOk` (301),
  `DeleteErr` (302), `PasswordSetOk` (401), `PasswordSetErr` (402), `ListOk` (501), `ListErr` (502),
  `ShowOk` (601), `ShowErr` (602), `RoleAddOk` (701), `RoleAddErr` (702), `RoleRemoveOk` (801),
  `RoleRemoveErr` (802), `RolesListOk` (901), `RolesListErr` (902), `PasswordSaltOk` (1001),
  `PasswordSaltErr` (1002), `PasswordValidateOk` (1101), `PasswordValidateErr` (1102),
  `PasswordUpdateOk` (1201), `PasswordUpdateErr` (1202)
- Payloads: user management request/response payloads are defined in `docs/admin/user-management.md`.
  Password payloads and salts follow `docs/iam/password-login.md`.

##### Users Password Payloads (Wire)

- `PasswordPayload` encodes as a tagged union:
  - `0` = `Plaintext { plaintext: String }`
  - `1` = `FrontEndHash { front_end_hash: String, front_end_salt: String }`
- `UserPasswordSetRequest { email, password, change_token? }`
  - `change_token` is optional and uses the option-bitset rules.
- `UserPasswordSaltRequest { email } -> PasswordSaltResponse { change_token, current_front_end_salt, next_front_end_salt, expires_in_seconds }`
- `UserPasswordValidateRequest { email, front_end_hash } -> PasswordValidateResponse { valid }`
- `UserPasswordUpdateRequest { email, current_front_end_hash, new_front_end_hash, new_front_end_salt, change_token }`

#### Tags (domain 11)

- Requests: `Add` (1), `Change` (2), `Delete` (3), `List` (4), `Show` (5)
- Responses: `AddOk` (101), `AddErr` (102), `ChangeOk` (201), `ChangeErr` (202), `DeleteOk` (301),
  `DeleteErr` (302), `ListOk` (401), `ListErr` (402), `ShowOk` (501), `ShowErr` (502)

#### Content (domain 12)

- Requests: `List` (1), `Read` (2), `Update` (3), `Delete` (4), `Upload` (5), `NavIndex` (6),
  `BinaryPrevalidate` (7), `BinaryUploadInit` (8), `BinaryUploadCommit` (9),
  `UploadStreamInit` (10), `UploadStreamCommit` (11), `UpdateStreamInit` (12),
  `UpdateStreamCommit` (13)
- Responses: `ListOk` (101), `ListErr` (102), `ReadOk` (201), `ReadErr` (202), `UpdateOk` (301),
  `UpdateErr` (302), `DeleteOk` (401), `DeleteErr` (402), `UploadOk` (501), `UploadErr` (502),
  `NavIndexOk` (601), `NavIndexErr` (602), `BinaryPrevalidateOk` (701),
  `BinaryPrevalidateErr` (702), `BinaryUploadInitOk` (801), `BinaryUploadInitErr` (802),
  `BinaryUploadCommitOk` (901), `BinaryUploadCommitErr` (902), `UploadStreamInitOk` (1001),
  `UploadStreamInitErr` (1002), `UploadStreamCommitOk` (1101), `UploadStreamCommitErr` (1102),
  `UpdateStreamInitOk` (1201), `UpdateStreamInitErr` (1202), `UpdateStreamCommitOk` (1301),
  `UpdateStreamCommitErr` (1302)

#### Content Domain ID-First Addressing

- Content-domain requests and responses must include a content ID and treat it as the primary
  identifier for read/update/delete flows.
- Alias fields become optional metadata fields; absence of an alias must be valid.
- Action IDs and payload shapes should be extended as needed to support ID-first requests while
  keeping legacy alias-based flows in a documented deprecation path.

#### Roles (domain 13)

- Requests: `Add` (1), `Change` (2), `Delete` (3), `List` (4), `Show` (5)
- Responses: `AddOk` (101), `AddErr` (102), `ChangeOk` (201), `ChangeErr` (202), `DeleteOk` (301),
  `DeleteErr` (302), `ListOk` (401), `ListErr` (402), `ShowOk` (501), `ShowErr` (502)

### Scope

- Applies to management socket envelopes and WebSocket frames.
- Payload serialization is manual; `serde` is only used for struct definitions.
- CLI bypass remains in-process and does not use the wire codec.
- Frame field ordering matches `docs/management/connector-socket.md`.

### Endianness and Primitives

- All integers are little-endian.
- `u8`, `u16`, `u32`, `u64`, `i32` encode as fixed-width bytes.
- `bool` encodes as `u8` with `0` = false and `1` = true (any other value is invalid).
- `String` encodes as `u32` byte length followed by UTF-8 bytes.
- `Vec<T>` encodes as `u32` element count followed by each element encoding.
- `Vec<u8>` uses the same length-prefix rules as `Vec<T>`.
- TypeScript uses `number` (safe integer) or `bigint` for `u64` writes; decoding uses `readU64Number()` when a safe `number` is required.

### Supported Types (Canonical)

- Scalars: `u8`, `u16`, `u32`, `u64`, `i32`, `bool`.
- Strings: `String` (UTF-8), length-prefixed.
- Bytes: `Vec<u8>` (length-prefixed).
- Lists: `Vec<T>` for any supported `T` (length-prefixed element count).
- Structs: fixed field order matching the Rust/TypeScript payload definitions.
- Optionals: encoded via the option bitset + per-field encoding (no inline `Option<T>` markers).
- Enums: encoded as their explicit integer representation (current payload enums use `u32`).

### Envelope Framing

Socket connector:

- Outer frame: `u32` length prefix (little-endian) for the envelope bytes; max `MAX_FRAME_BYTES` (2 MiB).
- Envelope fields (in order): `domain_id: u32`, `action_id: u32`, `workflow_id: u32`, `payload: bytes`.
- `payload` is length-prefixed (`u32` length) raw payload bytes.

WebSocket connector:

- Each WebSocket binary message is a single wire frame; max `WS_MAX_MESSAGE_BYTES` (63 KiB).
- WebSocket continuation frames are aggregated by the connector so protocol decoding always sees
  full messages (fragmentation is handled by the WebSocket implementation).
- Actix WebSocket parsing currently hard-caps frame payloads at 64 KiB even when a larger frame
  size is configured; keep `WS_MAX_MESSAGE_BYTES` below 64 KiB to avoid oversized frames.
- Frame header begins with `frame_type: u32` followed by variant fields.
- For frames that carry payloads (`Request`, `Response`, `StreamChunk`), payload bytes are length-prefixed (`u32`).

### Workflow ID Requirements

- `workflow_id` is required on every request and response.
- `workflow_id` is a `u32` assigned by the client and must be strictly increasing per connection.
- `workflow_id` value `0` is invalid and must be rejected by connectors.
- Clients allocate IDs with a monotonic counter; servers track the last accepted ID per connection and reject any `<=` value.
- When the counter would exhaust (`u32::MAX`), the client must reconnect and restart from `1`.
- Responses always echo the request `workflow_id` unchanged.

### Connection ID Requirements

- `connection_id` is a required `u32` used internally by the management bus for correlation.
- `connection_id` is not encoded on the wire; socket/WebSocket envelopes only include `workflow_id`.
- Connectors allocate a new `connection_id` for each accepted connection; internal callers (login/profile)
  allocate one per session or request.
- `connection_id` value `0` is invalid and must be rejected before dispatching to the bus.

### Optional-Field Bitset

- Payloads with optional fields include an option bitset as the first bytes of the payload.
- The bitset width is the smallest of `u8`, `u16`, `u32`, or `u64` that can represent all optional fields; more than 64 optional fields is invalid.
- Bit positions map 1:1 to the declared optional-field order for that payload type.
- A bit value of `1` means the optional field is present and encoded; `0` means it is omitted.
- The option bitset is always present when a payload defines optional fields, even if all bits are `0`.

### Field Ordering With Options

- Each payload has a canonical field order that matches the Rust and TypeScript definitions.
- Encoding order for payloads with optional fields:
  1. Option bitset.
  2. All fields in declared order; optional fields are encoded only when their bit is set.
- Decoders must validate the bitset width, reject unknown option bits, and reject trailing bytes.

### Option Bitset Selection Rules

- Let `N` = number of optional fields for the payload type.
- Choose the bitset width based on `N`:
  - `1..=8` -> `u8`
  - `9..=16` -> `u16`
  - `17..=32` -> `u32`
  - `33..=64` -> `u64`
- Bit ordering:
  - Optional field 0 maps to bit 0 (least-significant bit).
  - Optional field 1 maps to bit 1, and so on.
- The bitset width is not encoded; the decoder derives it from the payload type definition.

### Rust Codec Implementation

- `WireWriter`, `WireReader`, `WireEncode`, `WireDecode`, and `OptionMap` live in `nop/src/management/wire.rs`.
- Payload structs implement `WireEncode`/`WireDecode` directly.
- `WireReader::ensure_fully_consumed()` rejects trailing bytes after decode.

Rust encode example (optional fields):

```rust
impl WireEncode for ContentUpdateStreamInitRequest {
    fn encode(&self, writer: &mut WireWriter) -> WireResult<()> {
        let option_flags = [
            self.new_alias.is_some(),
            self.title.is_some(),
            self.tags.is_some(),
            self.nav_title.is_some(),
            self.nav_parent_id.is_some(),
            self.nav_order.is_some(),
            self.theme.is_some(),
        ];
        OptionMap::from_flags(&option_flags)?.write(writer)?;

        writer.write_string(&self.alias)?;
        if let Some(value) = &self.new_alias {
            writer.write_string(value)?;
        }
        if let Some(value) = &self.title {
            writer.write_string(value)?;
        }
        if let Some(value) = &self.tags {
            writer.write_vec(value, |w, tag| w.write_string(tag))?;
        }
        if let Some(value) = &self.nav_title {
            writer.write_string(value)?;
        }
        if let Some(value) = &self.nav_parent_id {
            writer.write_string(value)?;
        }
        if let Some(value) = self.nav_order {
            writer.write_i32(value);
        }
        if let Some(value) = &self.theme {
            writer.write_string(value)?;
        }
        writer.write_u64(self.size_bytes);
        Ok(())
    }
}
```

### TypeScript Codec Implementation

- `WireWriter`, `WireReader`, and `OptionMap` live in `nop/ts/admin/src/protocol/wire.ts`.
- Payload encoders/decoders are per-domain functions (for example, `nop/ts/admin/src/protocol/content.ts`).

TypeScript encode example (optional fields):

```ts
export function encodeContentUpdateStreamInitRequest(
  payload: ContentUpdateStreamInitRequest,
): Uint8Array {
  const writer = new WireWriter();
  const optionFlags = [
    payload.newAlias !== undefined,
    payload.title !== undefined,
    payload.tags !== undefined,
    payload.navTitle !== undefined,
    payload.navParentId !== undefined,
    payload.navOrder !== undefined,
    payload.theme !== undefined,
  ];
  OptionMap.write(writer, optionFlags);

  writer.writeString(payload.alias);
  if (payload.newAlias !== undefined) {
    writer.writeString(payload.newAlias);
  }
  if (payload.title !== undefined) {
    writer.writeString(payload.title);
  }
  if (payload.tags !== undefined) {
    writer.writeVec(payload.tags, (w, tag) => w.writeString(tag));
  }
  if (payload.navTitle !== undefined) {
    writer.writeString(payload.navTitle);
  }
  if (payload.navParentId !== undefined) {
    writer.writeString(payload.navParentId);
  }
  if (payload.navOrder !== undefined) {
    writer.writeI32(payload.navOrder);
  }
  if (payload.theme !== undefined) {
    writer.writeString(payload.theme);
  }
  writer.writeU64(payload.sizeBytes);
  return writer.toUint8Array();
}
```

### Generic Encode/Decode Flow

1. `(domain_id, action_id)` selects the correct request/response codec.
2. If the payload defines optional fields, encode/decode the option bitset first.
3. Encode fields in declared order, writing optional fields only when their bit is set.
4. Validate limits and ensure no extra bytes remain for the payload.

### Optional Fields in Frames

- If a frame header introduces optional fields in the future, they must use the same bitset
  rules as payloads.
- The bitset must follow the fixed header fields and precede optional frame fields.
- Current frame headers define only required fields.

### Example Payload Encoding (Options)

Payload:

```
ContentUpdateStreamInitRequest {
  alias: String,
  new_alias: Option<String>,
  title: Option<String>,
  tags: Option<Vec<String>>,
  nav_title: Option<String>,
  nav_parent_id: Option<String>,
  nav_order: Option<i32>,
  theme: Option<String>,
  size_bytes: u64,
}
```

Field order:

1. Option bitset (7 optional fields -> `u8`).
2. Declared field order, encoding optionals only when present:
   `alias`, `new_alias`, `title`, `tags`, `nav_title`, `nav_parent_id`, `nav_order`, `theme`, `size_bytes`.

### Frame Codec Structure

Socket request envelope bytes (inside the length-prefixed frame):

```
domain_id: u32
action_id: u32
workflow_id: u32
payload: bytes (u32 length + payload bytes)
```

Socket response envelope bytes (inside the length-prefixed frame):

```
domain_id: u32
action_id: u32
workflow_id: u32
payload: bytes (u32 length + payload bytes)
```

WebSocket frame order:

- `frame_type` is a `u32` that matches the Rust/TypeScript enum variant order.
- `Auth`: `ticket` (String), `csrf_token` (String)
- `AuthOk`/`AuthErr`: `message` (String)
- `Request`: `domain_id` (u32), `action_id` (u32), `workflow_id` (u32), `payload` (bytes)
- `Response`: `domain_id` (u32), `action_id` (u32), `workflow_id` (u32), `payload` (bytes)
- `StreamChunk`: `stream_id` (u32), `seq` (u32), `flags` (u8), `payload` (bytes)
- `Ack`: `stream_id` (u32), `seq` (u32)
- `Error`: `message` (String)

### Validation and Limits

- Existing per-field limits (string lengths, list sizes, ranges) remain enforced during decode.
- Decoders must fail fast on:
  - Length prefixes that exceed configured limits.
  - Unknown action IDs or mismatched payload sizes.
  - Invalid UTF-8 or invalid boolean values.

### Testing Scope

#### Unit Tests (Rust)

- `nop/src/management/wire.rs` covers primitives, option bitsets, and error paths.
- `nop/src/management/socket/protocol.rs` covers frame round-trip and oversized frame rejection.
- `nop/src/management/ws/protocol.rs` covers frame round-trip and oversized frame rejection.
- `nop/tests/management_wire_vectors.rs` validates payload golden vectors.

#### Unit Tests (TypeScript)

- `nop/ts/admin/src/protocol/wire.test.ts` covers primitives and option bitsets.
- `nop/ts/admin/src/protocol/ws-protocol.test.ts` covers frame round-trips.
- `nop/ts/admin/src/protocol/wire-vectors.test.ts` validates payload golden vectors.

#### Cross-Language Alignment

- Shared golden vectors live in `nop/tests/fixtures/management-wire-vectors.json`.
- The JSON file is test-only and provides a language-neutral fixture for payloads and hex bytes.
- Optional fields are represented with `null` in JSON to indicate an omitted value.

#### End-to-End Coverage

- Rust integration tests (`nop/tests/admin_*.rs`, `nop/tests/cli_e2e.rs`) exercise request/response flows through the bus and connectors.
- Playwright suites under `tests/playwright` cover admin UI flows that rely on WebSocket frames.

<!--
This file is part of the product NoPressure.
SPDX-FileCopyrightText: 2025-2026 Zivatar Limited
SPDX-License-Identifier: AGPL-3.0-or-later
The code and documentation in this repository is licensed under the GNU Affero General Public License v3.0 or later (AGPL-3.0-or-later). See LICENSE.
-->
