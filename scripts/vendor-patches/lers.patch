--- a/Cargo.toml
+++ b/Cargo.toml
@@ -118,7 +118,7 @@
 version = "0.1"
 
 [dependencies.trust-dns-resolver]
-version = "0.22"
+version = "0.23"
 optional = true
 
 [dependencies.uuid]
--- a/Cargo.toml.orig
+++ b/Cargo.toml.orig
@@ -40,7 +40,7 @@
 serde_json = "1"
 tokio = { version = "1", features = ["fs", "time"] }
 tracing = "0.1"
-trust-dns-resolver = { version = "0.22", optional = true }
+trust-dns-resolver = { version = "0.23", optional = true }
 uuid = { version = "1.3.0", features = ["v4"], optional = true }
 
 [dev-dependencies]
--- a/src/account.rs
+++ b/src/account.rs
@@ -206,7 +206,7 @@
     }
 
     /// Access the builder to issue a new certificate.
-    pub fn certificate(&self) -> CertificateBuilder {
+    pub fn certificate(&self) -> CertificateBuilder<'_> {
         CertificateBuilder::new(self)
     }
 
--- a/src/directory.rs
+++ b/src/directory.rs
@@ -91,7 +91,7 @@
     }
 
     /// Access the builder to lookup an existing or create a new account
-    pub fn account(&self) -> AccountBuilder<NoPrivateKey> {
+    pub fn account(&self) -> AccountBuilder<'_, NoPrivateKey> {
         AccountBuilder::<NoPrivateKey>::new(self.0.clone())
     }
 
--- a/src/order.rs
+++ b/src/order.rs
@@ -72,7 +72,7 @@
         skip_all,
         fields(self.id = self.url, self.status = ?self.inner.status),
     )]
-    pub async fn authorizations(&self) -> Result<Vec<Authorization>> {
+    pub async fn authorizations(&self) -> Result<Vec<Authorization<'_>>> {
         future::try_join_all(
             self.inner
                 .authorizations
--- a/src/solver/dns/cloudflare.rs
+++ b/src/solver/dns/cloudflare.rs
@@ -8,6 +8,7 @@
     Client, StatusCode,
 };
 use serde::{Deserialize, Serialize};
+use serde_json::Value;
 use std::{
     collections::HashMap,
     env,
@@ -17,6 +18,57 @@
 };
 use tracing::{instrument, Level};
 
+fn redact_cloudflare_value(value: &mut Value) {
+    match value {
+        Value::Object(map) => {
+            for (key, entry) in map.iter_mut() {
+                if matches!(
+                    key.as_str(),
+                    "content" | "token" | "api_key" | "api_token" | "value"
+                ) {
+                    *entry = Value::String("[redacted]".to_string());
+                } else {
+                    redact_cloudflare_value(entry);
+                }
+            }
+        }
+        Value::Array(items) => {
+            for item in items {
+                redact_cloudflare_value(item);
+            }
+        }
+        _ => {}
+    }
+}
+
+fn log_cloudflare_response(context: &str, status: StatusCode, body: &str) {
+    let mut parsed = serde_json::from_str::<Value>(body).unwrap_or(Value::String(body.to_string()));
+    redact_cloudflare_value(&mut parsed);
+    let success = parsed
+        .get("success")
+        .and_then(|value| value.as_bool())
+        .unwrap_or(status.is_success());
+    let rendered = match parsed {
+        Value::String(text) => text,
+        _ => serde_json::to_string(&parsed).unwrap_or_else(|_| "<unrenderable>".to_string()),
+    };
+    if success {
+        tracing::debug!(
+            "Cloudflare API response ({}): status={} body={}",
+            context,
+            status,
+            rendered
+        );
+    } else {
+        tracing::warn!(
+            "Cloudflare API response ({}): status={} body={}",
+            context,
+            status,
+            rendered
+        );
+    }
+}
+
 /// Errors that could be generated by the [`CloudflareDns01Solver`]
 #[derive(Debug)]
 pub enum CloudflareError {
@@ -108,16 +160,23 @@
         err,
         skip(self),
     )]
-    async fn zone_id_by_name(&self, name: &str) -> reqwest::Result<Option<String>> {
-        let response: Response<Vec<Zone>> = self
+    async fn zone_id_by_name(&self, name: &str) -> Result<Option<String>> {
+        let response = self
             .client
             .get("https://api.cloudflare.com/client/v4/zones")
             .query(&ListZoneOptions { name })
             .send()
-            .await?
-            .error_for_status()?
-            .json()
-            .await?;
+            .await
+            .map_err(Error::Reqwest)?;
+        let status = response.status();
+        let error = response.error_for_status_ref().err();
+        let body = response.text().await.map_err(Error::Reqwest)?;
+        log_cloudflare_response("zone_id_by_name", status, &body);
+        if let Some(err) = error {
+            return Err(Error::Reqwest(err));
+        }
+        let response: Response<Vec<Zone>> =
+            serde_json::from_str(&body).map_err(Error::Serialization)?;
 
         debug_assert!(response.success);
 
@@ -136,8 +195,8 @@
         zone_id: &str,
         name: &str,
         content: &str,
-    ) -> reqwest::Result<String> {
-        let response: Response<Record> = self
+    ) -> Result<String> {
+        let response = self
             .client
             .post(format!(
                 "https://api.cloudflare.com/client/v4/zones/{zone_id}/dns_records"
@@ -149,10 +208,17 @@
                 name,
             })
             .send()
-            .await?
-            .error_for_status()?
-            .json()
-            .await?;
+            .await
+            .map_err(Error::Reqwest)?;
+        let status = response.status();
+        let error = response.error_for_status_ref().err();
+        let body = response.text().await.map_err(Error::Reqwest)?;
+        log_cloudflare_response("set_txt_record", status, &body);
+        if let Some(err) = error {
+            return Err(Error::Reqwest(err));
+        }
+        let response: Response<Record> =
+            serde_json::from_str(&body).map_err(Error::Serialization)?;
 
         Ok(response.result.id)
     }
@@ -164,17 +230,24 @@
         err,
         skip(self),
     )]
-    async fn remove_record(&self, zone_id: &str, record_id: &str) -> reqwest::Result<()> {
+    async fn remove_record(&self, zone_id: &str, record_id: &str) -> Result<()> {
         let response = self
             .client
             .delete(format!(
                 "https://api.cloudflare.com/client/v4/zones/{zone_id}/dns_records/{record_id}"
             ))
             .send()
-            .await?;
-
-        if response.status() != StatusCode::NOT_FOUND {
-            response.error_for_status()?;
+            .await
+            .map_err(Error::Reqwest)?;
+        let status = response.status();
+        let error = response.error_for_status_ref().err();
+        let body = response.text().await.map_err(Error::Reqwest)?;
+        log_cloudflare_response("remove_record", status, &body);
+
+        if status != StatusCode::NOT_FOUND {
+            if let Some(err) = error {
+                return Err(Error::Reqwest(err));
+            }
         }
 
         Ok(())
@@ -331,7 +404,7 @@
     }
 
     #[test(tokio::test)]
-    async fn zone_id_by_name_valid() -> reqwest::Result<()> {
+    async fn zone_id_by_name_valid() -> Result<()> {
         let test_zone = env::var(ZONE_NAME_ENV).unwrap();
         let expected_id = env::var(ZONE_ID_ENV).ok();
 
@@ -343,7 +416,7 @@
     }
 
     #[test(tokio::test)]
-    async fn zone_id_by_name_invalid() -> reqwest::Result<()> {
+    async fn zone_id_by_name_invalid() -> Result<()> {
         let solver = solver();
         let id = solver.zone_id_by_name("lego.zz").await?;
         assert_eq!(id, None);
@@ -352,7 +425,7 @@
     }
 
     #[test(tokio::test)]
-    async fn txt_record() -> reqwest::Result<()> {
+    async fn txt_record() -> Result<()> {
         let zone = env::var(ZONE_NAME_ENV).unwrap();
         let zone_id = env::var(ZONE_ID_ENV).unwrap();
 
