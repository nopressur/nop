--- a/Cargo.toml
+++ b/Cargo.toml
@@ -94,7 +94,7 @@
 optional = true
 
 [dependencies.idna]
-version = "0.4.0"
+version = "1"
 
 [dependencies.ipnet]
 version = "2.3.0"
--- a/Cargo.toml.orig
+++ b/Cargo.toml.orig
@@ -78,7 +78,7 @@
 futures-util = { workspace = true, default-features = false, features = ["std"] }
 h2 = { workspace = true, features = ["stream"], optional = true }
 http = { workspace = true, optional = true }
-idna.workspace = true
+idna = "1"
 ipnet.workspace = true
 js-sys = { workspace = true, optional = true }
 native-tls = { workspace = true, optional = true }
--- a/src/error.rs
+++ b/src/error.rs
@@ -14,7 +14,6 @@
 #[cfg(feature = "backtrace")]
 #[cfg_attr(docsrs, doc(cfg(feature = "backtrace")))]
 pub use backtrace::Backtrace as ExtBacktrace;
-use enum_as_inner::EnumAsInner;
 #[cfg(feature = "backtrace")]
 use once_cell::sync::Lazy;
 use thiserror::Error;
@@ -57,7 +56,7 @@
 pub type ProtoResult<T> = ::std::result::Result<T, ProtoError>;
 
 /// The error kind for errors that get returned in the crate
-#[derive(Debug, EnumAsInner, Error)]
+#[derive(Debug, Error)]
 #[non_exhaustive]
 pub enum ProtoErrorKind {
     /// Query count is not one
--- a/src/rr/domain/label.rs
+++ b/src/rr/domain/label.rs
@@ -19,7 +19,8 @@
 use std::hash::{Hash, Hasher};
 use tinyvec::TinyVec;
 
-use idna;
+use idna::AsciiDenyList;
+use idna::uts46::{DnsLength, Hyphens, Uts46};
 use tracing::debug;
 
 use crate::error::*;
@@ -60,15 +61,12 @@
             return Self::from_ascii(s);
         }
 
-        match idna::Config::default()
-            .use_std3_ascii_rules(true)
-            .transitional_processing(true)
-            // length don't exceding 63 is done in `from_ascii`
-            // on puny encoded string
-            // idna error are opaque so early failure is not possible.
-            .verify_dns_length(false)
-            .to_ascii(s)
-        {
+        match Uts46::new().to_ascii(
+            s.as_bytes(),
+            AsciiDenyList::STD3,
+            Hyphens::Allow,
+            DnsLength::Ignore,
+        ) {
             Ok(puny) => Self::from_ascii(&puny),
             e => Err(format!("Label contains invalid characters: {e:?}").into()),
         }
@@ -245,14 +243,11 @@
         if self.as_bytes().starts_with(IDNA_PREFIX) {
             // this should never be outside the ascii codes...
             let label = String::from_utf8_lossy(self.borrow());
-            let (label, e) = idna::Config::default()
-                .use_std3_ascii_rules(false)
-                .transitional_processing(false)
-                .verify_dns_length(false)
-                .to_unicode(&label);
+            let (label, e) =
+                Uts46::new().to_unicode(label.as_bytes(), AsciiDenyList::EMPTY, Hyphens::Allow);
 
             if e.is_ok() {
-                return f.write_str(&label);
+                return f.write_str(label.as_ref());
             } else {
                 debug!(
                     "xn-- prefixed string did not translate via IDNA properly: {:?}",
--- a/src/rr/record_data.rs
+++ b/src/rr/record_data.rs
@@ -6,7 +6,6 @@
 // copied, modified, or distributed except according to those terms.
 
 //! record data enum variants
-#![allow(deprecated, clippy::use_self)] // allows us to deprecate RData types
 
 #[cfg(test)]
 use std::convert::From;
@@ -15,7 +14,6 @@
 #[cfg(feature = "serde-config")]
 use serde::{Deserialize, Serialize};
 
-use enum_as_inner::EnumAsInner;
 use tracing::{trace, warn};
 
 use crate::{
@@ -56,7 +54,7 @@
 /// length (including the length octet).
 /// ```
 #[cfg_attr(feature = "serde-config", derive(Deserialize, Serialize))]
-#[derive(Debug, EnumAsInner, PartialEq, Clone, Eq)]
+#[derive(Debug, PartialEq, Clone, Eq)]
 #[non_exhaustive]
 pub enum RData {
     /// ```text
@@ -691,12 +689,42 @@
         rdata: NULL,
     },
 
-    /// This corresponds to a record type of 0, unspecified
-    #[deprecated(note = "Use None for the RData in the resource record instead")]
-    ZERO,
 }
 
 impl RData {
+    /// Optionally return an A record.
+    pub fn as_a(&self) -> Option<&A> {
+        match self {
+            Self::A(value) => Some(value),
+            _ => None,
+        }
+    }
+
+    /// Optionally return an AAAA record.
+    pub fn as_aaaa(&self) -> Option<&AAAA> {
+        match self {
+            Self::AAAA(value) => Some(value),
+            _ => None,
+        }
+    }
+
+    /// Optionally return an SOA record.
+    pub fn as_soa(&self) -> Option<&SOA> {
+        match self {
+            Self::SOA(value) => Some(value),
+            _ => None,
+        }
+    }
+
+    /// Optionally return DNSSEC record data.
+    #[cfg(feature = "dnssec")]
+    pub fn as_dnssec(&self) -> Option<&DNSSECRData> {
+        match self {
+            Self::DNSSEC(value) => Some(value),
+            _ => None,
+        }
+    }
+
     fn to_bytes(&self) -> Vec<u8> {
         let mut buf: Vec<u8> = Vec::new();
         {
@@ -735,7 +763,6 @@
             #[cfg(feature = "dnssec")]
             Self::DNSSEC(ref rdata) => DNSSECRData::to_record_type(rdata),
             Self::Unknown { code, .. } => RecordType::Unknown(code),
-            Self::ZERO => RecordType::ZERO,
         }
     }
 
@@ -793,11 +820,9 @@
                 HTTPS::read_data(decoder, length).map(Self::HTTPS)
             }
             RecordType::ZERO => {
-                trace!("reading EMPTY");
-                // we should never get here, since ZERO should be 0 length, and None in the Record.
-                //   this invariant is verified below, and the decoding will fail with an err.
-                #[allow(deprecated)]
-                Ok(Self::ZERO)
+                return Err(
+                    ProtoErrorKind::Message("record type ZERO must not include RDATA").into(),
+                );
             }
             RecordType::MX => {
                 trace!("reading MX");
@@ -958,7 +983,6 @@
             Self::CSYNC(ref csync) => csync.emit(encoder),
             Self::HINFO(ref hinfo) => hinfo.emit(encoder),
             Self::HTTPS(ref https) => https.emit(encoder),
-            Self::ZERO => Ok(()),
             Self::MX(ref mx) => mx.emit(encoder),
             Self::NAPTR(ref naptr) => encoder.with_canonical_names(|encoder| naptr.emit(encoder)),
             Self::NULL(ref null) => null.emit(encoder),
@@ -1015,7 +1039,6 @@
             Self::CSYNC(ref csync) => w(f, csync),
             Self::HINFO(ref hinfo) => w(f, hinfo),
             Self::HTTPS(ref https) => w(f, https),
-            Self::ZERO => Ok(()),
             // to_lowercase for rfc4034 and rfc6840
             Self::MX(ref mx) => w(f, mx),
             Self::NAPTR(ref naptr) => w(f, naptr),
@@ -1274,7 +1297,6 @@
             #[cfg(feature = "dnssec")]
             RData::DNSSEC(ref rdata) => rdata.to_record_type(),
             RData::Unknown { code, .. } => RecordType::Unknown(code),
-            RData::ZERO => RecordType::ZERO,
         }
     }
 
--- a/src/serialize/binary/decoder.rs
+++ b/src/serialize/binary/decoder.rs
@@ -245,7 +245,7 @@
     }
 }
 
-#[cfg(tests)]
+#[cfg(test)]
 mod tests {
     use super::*;
 
--- a/src/serialize/txt/parse_rdata.rs
+++ b/src/serialize/txt/parse_rdata.rs
@@ -115,8 +115,9 @@
                 return Err(ParseError::from("RRSIG should be dynamically generated"))
             }
             RecordType::TSIG => return Err(ParseError::from("TSIG is only used during AXFR")),
-            #[allow(deprecated)]
-            RecordType::ZERO => Self::ZERO,
+            RecordType::ZERO => {
+                return Err(ParseError::from("record type ZERO must not include RDATA"));
+            }
             r @ RecordType::Unknown(..) => {
                 // TODO: add a way to associate generic record types to the zone
                 return Err(ParseError::from(ParseErrorKind::UnsupportedRecordType(r)));
--- a/src/udp/udp_stream.rs
+++ b/src/udp/udp_stream.rs
@@ -26,10 +26,10 @@
 pub(crate) type UdpCreator<S> = Arc<
     dyn Send
         + Sync
-        + (Fn(
+        + Fn(
             SocketAddr, // local addr
             SocketAddr, // server addr
-        ) -> Pin<Box<dyn Send + (Future<Output = Result<S, std::io::Error>>)>>),
+        ) -> Pin<Box<dyn Send + Future<Output = Result<S, std::io::Error>>>>,
 >;
 
 /// Trait for DnsUdpSocket
